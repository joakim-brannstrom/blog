# Mutation Testing of secp256k1

This article is a little journal about me getting mutation testing to work on
an open source project. Just so you know, the article assume that you have some
knowledge about [mutation testing](insert wiki link). Others have explained
what it is better than I ever have so I leave it to the exports.

I have been thinking lately that maybe the [tool](insert dextool link) is a bit
over-optimized for its main use case but I want it to be usable by a wider
audience. Thus I have taken to github and Internet to see what the problems
are, which I assume there are, of getting the tool to work on projects outside
of the *normal* users. If I can't get it working then how would I ever assume
that somebody else would bother using the tool.

There is also the, lets just be honest, ego playing in a bit here. It is fun to
see others use the tool and study what they do, what they find useful, what
they don't like in order to improve it! The feedback from users make the little
engineer inside me happy. A useful tool, a contribution to humanity.  I just
love it. I may come to regret these words.... but for now that is what I think
and feel.

So on to the story. I saw this comment
[secp256k1 on hackernews regarding mutation testing](https://news.ycombinator.com/item?id=26024915)
and got curious if it would be possible to run dextool.

    nullc 3 months ago [â€“]

    I've deployed mutation testing extensively in libsecp256k1 for the past five
    years or so, to good ends.

    Though it's turned up some testing inadequacies here and there and a
    substantial performance improvement (https://twitter.com/pwuille/status/1348835954396516353),
    I don't believe it's yet caught a bug there, but I do feel a lot more confident
    in the tests as a result.

    I've also deployed it to a lesser degree in the Bitcoin codebase and turned up
    some minor bugs as a result of the tests being improved to pass mutation
    testing.

    The biggest challenge I've seen for most parties to use mutation testing is
    that to begin with you must have 100% branch coverage of the code you might
    mutate, and very few ordinary pieces of software reach that level of coverage.

    The next issue is that in C/C++ there really aren't any great tools that I'm
    aware of-- so every effort needs to be homebrewed.

    My process is to have some a harness script that:

    1. makes a modification (e.g. a python script that does small search and
       replacements one at a time line by line, or just doing it by hand).
    2. attempts to compile the code (if it fails, move on to the next change)
    3. Compares the hash of the optimized binary to a collection of already tested
       hashes and moves onto the next if it's already been seen.
    4. Runs the tests and if the tests pass save off the diff.
    5. Goto 1.

    Then I go back trough the diffs and toss ones that are obviously no meaningful
    effect, and lob the remaining diffs over to other contributors to figure out if
    they're false positives or to improve the tests.


## Outline

write a story introduction.

why secp256k1.
write about the checksum. link dextool.
talk about TCE.

maturity of the tool and why I test it on open source projects.

## Booting!

initial problems.

first solution of manually linking the object code.
changing Makefile.am

changes needed to dextool to make it easier.
link to pull request.
compare the before and after result.

link to my github version of secp256k1.

## Result

how long did it take to execute?

example of console output, html output.

anything interesting?

##

just for fun. what happens if I take all surviving mutants and inject them at the same time!
at least sdl, I mean. they aren't needed?

what about the benchmarks. Is it faster now? what happened?

## Future

lessons learned and future improvements.


# Parallelize Datacat part 2

In the previous [article]() I talked about the initial work of parallelizing Datacat. I would dare say that the improvements in the end where acceptably good. But at the end I did mention an observation that I saw when analyzing the behavior of `datacat` for the larger datasets. Namely that it *seems* to be stuck in a single thread at the end for a noticeable time. My suspicion is that this is the call to `Variable.complete`. Let us investigate this and see if we can parallelize it.

**Note**: The parallelizing has focused on smaller blocks. In the future I may do a rewrite to a more *dataflow* centric architecture. I'll also explore if [DCompute]() can be used. I do see a similarity between image processing with *kernels* and what a *rule* in `datacat` do with data consisting of simple types.

**Note**: Some further thinking of the subject and [mir]() came to my mind. I just have to investigate using that excellent library too.

# Analyze

Let us start by gather data before jumping to any conclusions. A hunch is a good start but let us support it with data. I think the following will be enough:
 * [DMD]() instrumentation
 * manual instrumentation of the source code to see how much time is spent in `Variable.complete`.

Just for kicks and fun let us also run with [valgrin allocator checker](). It is so easy so why not?

## Profile

Lets gather some new profile data once again but this time from both the coarse grained test suite and the `http_df` graspan1 dataset.

```sh
cd test/standalone
dub build -p profile
./build/graspan1 http_df

[test/standalone] ./build/graspan1 ../httpd_df
Shall calculate the dataflow from the provided file
2 minutes, 37 secs, 495 ms, 626 μs, and 6 hnsecs: Data loaded
Single threaded
13 minutes, 51 secs, 366 ms, 163 μs, and 7 hnsecs: Computation complete (nodes_final: 9393283)
Multi threaded
```

After 20min I started thinking that something is wrong. I looked at the processes and CPU usage with `htop` and noticed that the threads where idle. Interesting! It seems like the profiling via [DMD]() do not support multiple threads. Well that isn't much of a problem for us. We need the characteristics of a single thread. That then help us load balance that work across multiple threads.

After a rewrite of the [graspan1](https://github.com/joakim-brannstrom/datacat/pull/15) application to take a parameter that control single/multiple threads I where ready to once again execute the tests.
```sh
cd test/standalone
dub build -p profile
./build/graspan1 http_df
```


To reproduce the results I give you:
```sh
dub fetch profdump

cd test
dub build -p utProf
./build/datacat_benchmark

dub run profdump -- -d -f trace.log trace.dot
dot -Tsvg trace.dot -o trace.svg

cd standalone
dub build -p profile
./build/graspan1 http_df

dub run profdump -- -d -f trace.log trace.dot
dot -Tsvg trace.dot -o trace.svg
```

Let us look into the profile for `datacat_benchmark`.
![profile of datacat_benchmark](https://github.com/joakim-brannstrom/blog/blob/master/assets)/)


